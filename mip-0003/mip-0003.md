```
MIP: 3
Title: Delegated keys
Author: Jason Chavannes <jason@memo.cash>
Status: Draft
Created: 2018-09-13
```

## Abstract

Associate multiple keys in a hierarchy with a single identity.
The original parent key will be the main address associated with the identity.

## Motivation

Having only a single key associated with an identity has a couple of limitations.
First, your identity can only be associated with a single service.
Second, you must trust that service to practice good security with your key
and cannot use security measures like cold storage if your identity is being used regularly.

Having a hierarchy of keys enables linking an identity across multiple services.
The primary keys at the top of the tree can be secured in cold storage.
Intermediate keys can be used similar to being your own certificate authority
and using intermediate certs.
Can use schemes similar to OAuth to easily sign-in and link identity between services.

Can also be extended in the future to limit capabilities of child keys.
For instance you might want a service to be able to post on your behalf
but not change your name.

Another action that could be added are aliases.
Even though posts would be associated with a single identity,
you would know which services they came through.
 

## Specification

#### Protocol Actions

| Action | Prefix | Values |
|---|---|---|
| Parent request (MPR) | 0x6d20 | address(20), message(196) |
| Child accept (MCA) | 0x6d21 | txhash(32), message(184) |
| Child revoke (MCR) | 0x6d22 | address(20), message(196) |

#### Identities

An address that has never issued a parent request (MPR) or child acceptance (MCA) is called a **dangler**.
Once two danglers are linked they become an **identity**.

The main identifier address for the identity is the dangler with activity in the earliest block.
If neither dangler has activity in an earlier block or they both have activity in the same earliest block,
then the parent becomes the main identifier.

Once an **identity** has been formed, only **danglers** can be added (either as parents or children).
E.g. a parent of one identity cannot become a child of another identity.

There are no time limits on how long a **dangler** and an **identity** can exist in parallel before being linked.
One use case for this would be creating an account on a new service.
Rather than immediately linking the account to your main identity, you can use it temporarily as a dangler.

If a new dangler is added to an identity that has activity in an earlier block than the main identifier address,
it will not change the main identifier.
Only the original two danglers are eligible to be the main identifier.

Once an address has been linked to an identity it cannot be linked to another identity.
If a child is revoked any further actions by that address will be ignored.

It is possible and even likely that the original addresses used for an **identity** will eventually be rotated out.
Even though they are revoked, the main identifier will still be used.

The main identifier is not currently part of the protocol necessarily.
Its purpose is just for a canonical lookup.

## Example Flows

#### Service Signup

1. You have an existing identity using a service provider like memo (Key A)
    ```
    A
    ```

2. You signup for a new service and choose to use Memo auth
3. The site creates a new key (Key B) and issues an MPR transaction
    ```
    A    B
    ```

4. You are redirected to Memo to accept the MPR (using an MCA)
5. The child acceptance transaction is sent and redirected back to new service
    ```
      A
     /
    B
    ```

6. Accounts are now linked, also no login required for new service

Fine to use Key B with site for awhile before linking to main Key A identity if desired.



### Key Rotation

Assume existing hierarchy of Keys A, B, and C:

```
    A
   /
  B
 /
C
```

To replace Key B, create and link Keys D and E and
start using instead of Keys B and C.

```
    A
   / \
  B   D
 /   /
C   E
```

Once all uses of Key B have been updated to use Key D (and C to E),
revoke Key B.

```
    A
   /
  D
 /
E
```

### Master Key Replacement

In the case where you want to replace the master key it's a similar process.
Assume existing hierarchy of Keys A, B, and C:

```
    A
   /
  B
 /
C
```

To replace Key A, create and link Keys D, E, and F and
start using instead of Keys A, B, and C.

```
      D
     / \
    A   E
   /   /
  B   F
 /
C
```

Once all uses of Key A have been updated to use Key D (and B to E, and C to F),
revoke Key A.

```
    D
   /
  E
 /
F
```

Even though no longer a valid key, the main identifier for the identity will remain the same.

### Compromised Child Key

If a child key is compromised, can revoke it to start ignoring actions.
Actions would still exist with the child key, but they will be disassociated with your identity.


## Reference Implementation

Planned

## See Also
